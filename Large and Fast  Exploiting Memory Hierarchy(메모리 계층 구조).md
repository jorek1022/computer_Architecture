# (작성중)Large and Fast : Exploiting Memory Hierarchy(메모리 계층 구조)



## RAM (Random Access Memory)

- **DRAM(Dynamic RAM)** 

  - 매우 빠름

  - refresh 안 해도 내용이 유지

  - 1비트를 기억하기 위해 4 to 6의 transistor를 사용

- **SRAM(Static RAM)**

  - SRAM보다는 느림
  - refresh를 해야 내용이 유지가 됨





## Exploiting Memory Hierarchy

| Memory technology          | Typical access time     | $ per GIB in 2012 |
| -------------------------- | ----------------------- | ----------------- |
| SRAM semiconductor memory  | 0.5-2.5 ns              | $500-$1000        |
| DRAM semiconductor memory  | 50-70 ns                | $10-$20           |
| Flash semiconductor memory | 5,000-50,000 ns         | $0.75-$1.00       |
| Magnetic disk              | 5,000,000-20,000,000 ns | $0.05-$0.10       |

![image](https://user-images.githubusercontent.com/33410490/69794845-58fc6700-120e-11ea-9e1d-47c66990460f.png)





## 메모리를 두 레벨의 영역으로 나눈다고 가정

#### two levels (Upper, Lower)

- #### block : data의 최소 단위

- #### hit : 요청된 data가 Upper level에 존재

- #### miss : 요정된 data가 Upper level에 존재하지 않음

![메모리를 두 레벨로 나눈 것](https://user-images.githubusercontent.com/33410490/69795095-e049da80-120e-11ea-90c0-d7f4bb5802f0.png)





## Locality 의 법칙(Principle of Locality)

#### Locality : 기억 장치 내의 정보를 균일하게 접근하는 것이 아닌 어느 한 순간에 특정 부분을 집중적으로 참조하는 특성

- #### *Temporal locality(시간적 지역성)* : 최근 사용되었던 기억 장소들이 집중적으로 access되는 경향 / 프로그램 실행 시 한 번 접근이 이루어진 주소의 메모리 영역은 자주 접하게 된다는 의미

- #### *Spatical locality(공간적 지역성)* : 특정 클레스터의 기억 장소들에 대해 참조가 집중적으로 이루어지는 경향 / 프로그램 실행시 접근하는 메모리의 영역은 이미 접근이 이루어진 영역 근처일 확률이 높다는 의미



## Basic of Cache(캐시)

![image](https://user-images.githubusercontent.com/33410490/69797251-b85c7600-1212-11ea-9d29-1dbc8a640dab.png)

#### 두 가지 issues:

- data가 cache에 있는 지 없는 지를 어떻게 알 수 있을까?
- 만약,  data가 있다는 걸 안다면, 어디에 있는 지 어떻게 찾을 수 있을까?





## Direct Mapped Cache(*`word addressing`*)

#### word addressing : word마다 주소가 있음

#### `cache index = memory address % the number of blocks in the cache`

![image](https://user-images.githubusercontent.com/33410490/69799377-84834f80-1216-11ea-9896-4bedd8b44f8e.png)

word마다 주소가 있으므로 **한 block이 4byte**임



#### < issues >

- **valid bit**가 필요 :

  값이 있는 지 없는 지를 확인하기 위해

- **tag**가 필요 : **(index로 쓰이는 bit(끝의 n bit)를 제외한 나머지 bit로 구분)**

  cache에 저장 된 값이 어디서 온 것인지 구분하기 위해



#### < 예시 >

mm blocks 32개

1 block = 4bytes

32 * 4 = 128bytes = 2의 8승

-> **cache 8개!!!!**

8개는 3bit로 표현 가능!! 

즉, cache index는 **cache가 2의 n승**이라고 했을 때 **원래 메모리 주소의 *끝의 n bit*가 나머지**!!

![image](https://user-images.githubusercontent.com/33410490/69801935-b77c1200-121b-11ea-869b-64bfe3e73a4a.png)

#### Cache conflict : 서로 다른 주소가 경쟁하여 지우고 새로 쓰는 것

#### Compulsory miss : 그 메모리를 저음 access할 때 발생하는 miss (22, 26, 16, 3 and 8)





## Direct Mapped Cache (*`byte addressing`*)

​																																			**word**

![image](https://user-images.githubusercontent.com/33410490/69802849-d9769400-121d-11ea-8d37-598e15bcc1a5.png)

Index가 0~ 1023이므로 block : 1024개

Cache index로는 10bit 필요

끝의 두 bit는 단어를 위한 Byte offest이므로, 끝의 두 bit를 제외한 10bit가 cache의 index

